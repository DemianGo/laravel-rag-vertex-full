<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Throwable;
use App\Services\VertexClient;

class RagController extends Controller
{
    public function ping(Request $request)
    {
        return response()->json(['ok' => true, 'who' => 'api.ping']);
    }

    protected function vertex(): VertexClient
    {
        // resolvido pelo container do Laravel
        return app(VertexClient::class);
    }

    public function ingest(Request $request)
    {
        $tenant = trim((string) $request->input('tenant', 'default'));
        $title  = trim((string) $request->input('title', 'Untitled'));
        $text   = trim((string) $request->input('text', ''));

        if ($text === '') {
            return response()->json(['ok'=>false,'error'=>'Campo "text" é obrigatório'], 400);
        }

        try {
            // 1) cria o documento
            $docId = DB::table('documents')->insertGetId([
                'tenant_slug' => $tenant,
                'title'       => $title,
                'source'      => 'manual',
                'meta'        => null,
                'created_at'  => now(),
                'updated_at'  => now(),
            ]);

            // 2) chunk simples (tudo em 1 bloco) – dá pra evoluir depois
            $chunks = [ $text ];

            foreach ($chunks as $i => $content) {
                // 2a) embedding via Vertex
                $client = $this->vertex();
                if (method_exists($client, 'embedText')) {
                    $vec = $client->embedText($content);
                } elseif (method_exists($client, 'embed')) {
                    $vec = $client->embed($content);
                } else {
                    throw new \RuntimeException('Método de embedding não encontrado no VertexClient');
                }
                if (!is_array($vec) || empty($vec)) {
                    throw new \RuntimeException('Embedding vazio');
                }

                // vetor em literal pgvector: [a,b,c]::vector(768)
                $vecLiteral = '[' . implode(',', array_map(fn($v) => is_numeric($v) ? $v : 0, $vec)) . ']::vector(' . count($vec) . ')';

                // 2b) insert no chunks (meta json + embedding vetorial)
                // usa literal do vetor direto na SQL (não dá pra bindar o tipo vector nativamente)
                DB::statement(
                    'INSERT INTO chunks (document_id, chunk_index, content, meta, created_at, updated_at, embedding)
                     VALUES (?, ?, ?, ?::jsonb, NOW(), NOW(), ' . $vecLiteral . ')',
                    [
                        $docId,
                        $i,
                        $content,
                        json_encode(['len' => mb_strlen($content)]),
                    ]
                );
            }

            return response()->json(['ok'=>true,'doc_id'=>$docId,'chunks'=>count($chunks)]);
        } catch (Throwable $e) {
            return response()->json(['ok'=>false,'error'=>$e->getMessage()], 500);
        }
    }

    public function query(Request $request)
    {
        $tenant = trim((string) $request->input('tenant', ''));
        $q      = trim((string) $request->input('query', ''));
        $topK   = (int) $request->input('top_k', 3);
        $topK   = max(1, min(20, $topK)); // segura o LIMIT como inteiro

        if ($q === '') {
            return response()->json(['ok'=>false,'error'=>'Campo "query" é obrigatório'], 400);
        }

        try {
            // 1) embedding da consulta
            $client = $this->vertex();
            if (method_exists($client, 'embedText')) {
                $qvec = $client->embedText($q);
            } elseif (method_exists($client, 'embed')) {
                $qvec = $client->embed($q);
            } else {
                throw new \RuntimeException('Método de embedding não encontrado no VertexClient');
            }
            if (!is_array($qvec) || empty($qvec)) {
                throw new \RuntimeException('Embedding de consulta vazio');
            }
            $vecLiteral = '[' . implode(',', array_map(fn($v) => is_numeric($v) ? $v : 0, $qvec)) . ']::vector(' . count($qvec) . ')';

            // 2) monta SQL com filtro de tenant **apenas se** houver valor
            $sql = "
                SELECT
                    c.id, c.document_id, c.chunk_index, c.content,
                    1 - (c.embedding <=> {$vecLiteral}) AS score
                FROM chunks c
                JOIN documents d ON d.id = c.document_id
                WHERE 1=1
            ";
            $bindings = [];

            if ($tenant !== '') {
                $sql .= " AND d.tenant_slug = :tenant";
                $bindings['tenant'] = $tenant;
            }

            $sql .= " ORDER BY c.embedding <=> {$vecLiteral} ASC LIMIT {$topK}";

            $rows = DB::select($sql, $bindings);

            return response()->json([
                'ok'      => true,
                'matches' => array_map(function ($r) {
                    return [
                        'id'          => (int) $r->id,
                        'document_id' => (int) $r->document_id,
                        'chunk_index' => (int) $r->chunk_index,
                        'content'     => $r->content,
                        'score'       => (float) $r->score,
                    ];
                }, $rows)
            ]);
        } catch (Throwable $e) {
            return response()->json(['ok'=>false,'error'=>$e->getMessage()], 500);
        }
    }
}
