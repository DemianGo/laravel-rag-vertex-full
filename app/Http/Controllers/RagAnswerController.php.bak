<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use App\Services\LlmService;
use App\Services\SummaryBullets;

class RagAnswerController extends Controller
{
    public function answer(Request $request)
    {
        $docId = $request->input('document_id', $request->query('document_id'));
        $query = $request->input('query', $request->query('query'));
        $topK  = intval($request->input('top_k', $request->query('top_k', 6)));

        if (!$docId || !$query) {
return response()->json([
                'ok' => false,
                'error' => 'Parâmetros obrigatórios: document_id e query.'
            ], 422);
        }

        $k = max(1, min(30, $topK));

        $modeParam      = strtolower((string)$request->input('mode', $request->query('mode', 'auto')));
        $mode           = $this->detectMode($modeParam, $query);
        $lengthParam    = strtolower((string)$request->input('length', $request->query('length', 'auto')));
        $length         = $this->normalizeLength($lengthParam);
        $format         = strtolower((string)$request->input('format', $request->query('format', 'plain')));
        $strictness     = max(0, min(3, intval($request->input('strictness', $request->query('strictness', 2)))));
        $citationsCount = max(0, min(10, intval($request->input('citations', $request->query('citations', 0)))));

        // ----------------- Recuperação (FTS Postgres → fallback genérico) -----------------
        $tokensRaw  = $this->tokensRaw($query);
        $tokensNorm = $this->tokensNorm($query);
        $tokensRaw  = array_slice(array_values(array_unique($tokensRaw)), 0, 10);
        $tokensNorm = array_slice(array_values(array_unique($tokensNorm)), 0, 10);

        $rows = [];

        // Tenta FTS nativo do Postgres (quando habilitado)
        if (count($tokensRaw) && $this->isPgsql() && $this->pgFtsEnabled()) {
            $rows = $this->tryPgFts((int)$docId, $k, $tokensRaw);
        }

        // Fallback textual (portável para MySQL/SQLite)
        if (count($rows) === 0) {
            $terms = array_values(array_unique(array_merge($tokensRaw, $tokensNorm)));
            $terms = $this->expandQueryTerms($terms, $query, (int)$docId);
            $terms = array_slice($terms, 0, 12);

            if (count($terms)) {
                $bindings = ['doc' => $docId];

                if ($this->isPgsql()) {
                    $likeOp = 'ILIKE';
                    $where = [];
                    foreach ($terms as $i => $t) {
                        $p = "t{$i}";
                        $where[] = "content $likeOp '%' || :$p || '%'";
                        $bindings[$p] = $t;
                    }
                    $sql = "
                        SELECT id, ord, content, document_id
                        FROM chunks
                        WHERE document_id = :doc
                          AND (" . implode(' OR ', $where) . ")
                        ORDER BY ord ASC
                        LIMIT $k
                    ";
                } elseif ($this->isMysql()) {
                    $where = [];
                    foreach ($terms as $i => $t) {
                        $p = "t{$i}";
                        $where[] = "content LIKE CONCAT('%', :$p, '%')";
                        $bindings[$p] = $t;
                    }
                    $sql = "
                        SELECT id, ord, content, document_id
                        FROM chunks
                        WHERE document_id = :doc
                          AND (" . implode(' OR ', $where) . ")
                        ORDER BY ord ASC
                        LIMIT $k
                    ";
                } else { // SQLite
                    $where = [];
                    foreach ($terms as $i => $t) {
                        $p = "t{$i}";
                        $where[] = "content LIKE '%' || :$p || '%'";
                        $bindings[$p] = $t;
                    }
                    $sql = "
                        SELECT id, ord, content, document_id
                        FROM chunks
                        WHERE document_id = :doc
                          AND (" . implode(' OR ', $where) . ")
                        ORDER BY ord ASC
                        LIMIT $k
                    ";
                }

                try {
                    $rows = DB::select($sql, $bindings);
                } catch (\Throwable $e) {
                    // Último fallback ultra simples: primeiros chunks do doc
                    $rows = DB::table('chunks')
                        ->select(['id','ord','content','document_id'])
                        ->where('document_id', $docId)
                        ->orderBy('ord', 'asc')
                        ->limit($k)
                        ->get()
                        ->all();
                }
            }
        }

        // === FIX: garantir contrato quando não há rows, com atenção a QUOTE ===
        if (count($rows) === 0) {
            if ($mode === 'quote') {
                return response()->json([
                    'ok'          => true,
                    'query'       => $query,
                    'top_k'       => $k,
                    'used_doc'    => intval($docId),
                    'used_chunks' => 0,
                    'mode_used'   => 'quote',
                    'format'      => $format,
                    'answer'      => '“Sem citação disponível no contexto.”',
                    'sources'     => [],
                    'debug'       => [
                        'mode'         => 'fts_or_text_fallback_empty',
                        'llm_used'     => false,
                        'best_ord'     => null,
                        'llm_provider' => env('LLM_PROVIDER', 'none'),
                    ],
                ]);
            }

            return response()->json([
                'ok'          => true,
                'query'       => $query,
                'top_k'       => $k,
                'used_doc'    => intval($docId),
                'used_chunks' => 0,
                'mode_used'   => $mode,   // sempre presente no topo
                'format'      => $format,
                'answer'      => 'Não há dados suficientes no documento para responder.',
                'sources'     => [],
                'debug'       => [
                    'mode'       => 'fts_or_text_fallback_empty',
                    'llm_used'   => false,
                    'mode_used'  => $mode,
                ],
            ]);
        }

        // ----------------- Seleção de fluxo -----------------
        $best    = (array)$rows[0];
        $bestOrd = intval($best['ord'] ?? $best['ORD'] ?? 0);

        $llmUsed = false;
        $sources = [];

        // ===== LIST =====
        if ($mode === 'list' || ($mode === 'auto' && $this->hasListIntent($query))) {
            $neighbors = $this->loadAllChunks((int)$docId);
            $combined  = $this->combineChunksForList($neighbors);
            $items     = $this->extractNumberedItems($combined);
            $itemsCount = count($items);

            // Se não houver itens numerados, sintetiza 3–6 bullets a partir das frases
            if ($itemsCount === 0) {
                $neighborsWin = $this->loadOrdWindow((int)$docId, max(0, $bestOrd - 2), $bestOrd + 40);
                $candidates = [];
                foreach ($neighborsWin as $n) {
                    $ord = $n->ord ?? null;
                    $cid = $n->id ?? null;
                    $text = $this->repairText((string)$n->content);
                    foreach ($this->splitSentences($text) as $s) {
                        $s = trim($s);
                        if ($s === '') continue;
                        $candidates[] = ['text' => $s, 'chunk_id' => $cid, 'ord' => $ord, 'score' => 0.0];
                    }
                }
                $sb   = app(SummaryBullets::class);
                $pack = $sb->build($candidates, 3, 6, $citationsCount);
                $bullets = $pack['bullets'];

                if ($strictness < 3) {
                    try {
                        $llm = new LlmService();
                        if ($llm->enabled()) {
                            foreach ($bullets as &$b) {
                                $txt = (string)($b['text'] ?? '');
                                $rv  = $llm->rewriteLine($txt, $format);
                                $b['text'] = is_string($rv) && strlen(trim($rv)) > 0 ? trim($rv) : $txt;
                            }
                            unset($b);
                            $llmUsed = true;
                        }
                    } catch (\Throwable $e) {}
                }

                $vals  = array_values(array_map(fn($b)=>trim((string)$b['text']), $bullets));
                $items = [];
                foreach ($vals as $v) { $items[] = $v; }
                $answer  = $this->formatNumberedList(array_combine(range(1,count($items)), $items), $format);
                $sources = $this->buildCitationsFromWindow($neighborsWin, $citationsCount);

                return response()->json([
                    'ok' => true,
                    'query' => $query,
                    'top_k' => $k,
                    'used_doc' => intval($docId),
                    'used_chunks' => count($neighborsWin),
                    'mode_used' => 'list',
                    'format' => $format,
                    'answer' => $answer,
                    'sources' => $sources,
                    'debug' => [
                        'mode' => $llmUsed ? 'list_fallback_bulleted_llm' : 'list_fallback_bulleted',
                        'best_ord' => $bestOrd,
                        'items_found' => 0,
                        'llm_used' => $llmUsed,
                        'llm_provider' => env('LLM_PROVIDER', 'none'),
                    ],
                ]);
            }

            // Há itens numerados nativos:
            if ($length === 'short' && $itemsCount > 6) {
                $items = array_slice($items, 0, 6, true);
            } elseif ($length === 'medium' && $itemsCount > 15) {
                $items = array_slice($items, 0, 15, true);
            }

            $answer  = $this->formatNumberedList($items, $format);
            $sources = $this->buildCitationsFromWindow($neighbors, $citationsCount);
            $modeUsed = 'list';
            $debugMode = 'list_mode_extractive';

            if ($strictness < 3) {
                try {
                    $llm = new LlmService();
                    if ($llm->enabled()) {
                        $refined = [];
                        foreach ($items as $n => $val) {
                            $rv = $llm->rewriteLine($val, $format);
                            $refined[$n] = is_string($rv) && strlen(trim($rv)) > 0 ? trim($rv) : $val;
                        }
                        $answer  = $this->formatNumberedList($refined, $format);
                        $llmUsed = true;
                        $modeUsed = 'list_llm_refine_per_item';
                        $debugMode = 'list_mode_llm_refine_per_item';
                    }
                } catch (\Throwable $e) {}
            }

            return response()->json([
                'ok' => true,
                'query' => $query,
                'top_k' => $k,
                'used_doc' => intval($docId),
                'used_chunks' => count($neighbors),
                'mode_used' => $modeUsed,
                'format' => $format,
                'answer' => $answer,
                'sources' => $sources,
                'debug' => [
                    'mode' => $debugMode,
                    'best_ord' => $bestOrd,
                    'window' => [0, count($neighbors) ? end($neighbors)->ord : 0],
                    'items_found' => $itemsCount,
                    'llm_used' => $llmUsed,
                    'llm_provider' => env('LLM_PROVIDER', 'none'),
                ],
            ]);
        }

        // ===== TABELA =====
        if ($mode === 'table' || ($mode === 'auto' && $this->hasTableIntent($query))) {
            $neighbors = $this->loadOrdWindow((int)$docId, max(0, $bestOrd - 2), $bestOrd + 30);
            $combined  = $this->combineChunks($neighbors);
            $pairs     = $this->extractKeyValuePairs($combined);

            if (!empty($pairs)) {
                $answer  = $this->formatTable($pairs, $format);
                $sources = $this->buildCitationsFromWindow($neighbors, $citationsCount);
                return response()->json([
                    'ok' => true,
                    'query' => $query,
                    'top_k' => $k,
                    'used_doc' => intval($docId),
                    'used_chunks' => count($neighbors),
                    'mode_used' => 'table',
                    'format' => $format,
                    'answer' => $answer,
                    'sources' => $sources,
                    'debug' => [
                        'mode' => 'table_mode_extractive',
                        'best_ord' => $bestOrd,
                        'llm_used' => false
                    ],
                ]);
            }
        }

        // ===== DIRECT =====
        $candidates = array_values(array_unique(array_filter([$bestOrd - 1, $bestOrd, $bestOrd + 1], fn($x) => $x >= 0)));
        $in = implode(',', $candidates);

        $neighbors = DB::select("
            SELECT id, ord, content, document_id
            FROM chunks
            WHERE document_id = :doc AND ord IN ($in)
            ORDER BY ord ASC
        ", ['doc' => $docId]);

        $combined   = $this->combineChunks($neighbors);
        $extractive = $this->extractAnswer($combined, $query);
        $final      = $extractive ?: 'Não há dados suficientes para responder com precisão.';
        $modeUsed   = 'direct';

        // ===== QUOTE (sempre retorna algo quando solicitado) =====
        if ($mode === 'quote' || ($mode === 'auto' && $this->hasQuoteIntent($query))) {
            $quote  = $this->buildQuoteFallback($combined, $extractive);
            $1
            $final = $this->formatAs($this->ensureDoubleQuoted($quote), $format);
            $sources = $this->buildCitationsFromNeighbors($neighbors, $citationsCount);

            return response()->json([
                'ok' => true,
                'query' => $query,
                'top_k' => $k,
                'used_doc' => intval($docId),
                'used_chunks' => count($neighbors),
                'mode_used' => 'quote',
                'format' => $format,
                'answer' => $final,
                'sources' => $sources,
                'debug' => [
                    'mode' => 'extractive_quote',
                    'best_ord' => $bestOrd,
                    'neighbors' => array_map(fn($n) => ['id' => $n->id, 'ord' => $n->ord], $neighbors),
                    'llm_used' => false
                ],
            ]);
        }

        // ===== SUMMARY (sempre bullets 3–5) =====
        if ($mode === 'summary' || ($mode === 'auto' && $this->hasSummaryIntent($query))) {
            $neighbors = $this->loadOrdWindow((int)$docId, max(0, $bestOrd - 2), $bestOrd + 40);

            // Constrói candidatos de frases (conservando quebras de linha)
            $candidates = [];
            foreach ($neighbors as $n) {
                $ord = $n->ord ?? null;
                $cid = $n->id ?? null;
                $text = $this->repairTextKeepBreaks((string)$n->content); // <<<<<< preserva \n
                foreach ($this->splitSentencesLoose($text) as $s) {       // <<<<<< segmenta por linhas + pontuação
                    $s = trim($s);
                    if ($s === '') continue;
                    $candidates[] = ['text' => $s, 'chunk_id' => $cid, 'ord' => $ord, 'score' => 0.0];
                }
            }

            // Seleciona 3–5 sem redundância forte
            $sb   = app(SummaryBullets::class);
            $pack = $sb->build($candidates, 3, 5, $citationsCount);
            $bullets = $pack['bullets'];

            // Fallback: se vier menos de 3 bullets, cria bullets a partir de linhas do contexto
            if (count($bullets) < 3) {
                $linePool = [];
                foreach ($neighbors as $nn) {
                    $tt = $this->repairTextKeepBreaks((string)$nn->content);
                    $ls = preg_split('/\R+/u', $tt, -1, PREG_SPLIT_NO_EMPTY);
                    foreach ($ls as $l) {
                        $l = trim(preg_replace('/^\s*(?:[\-–—\*•]\s+|\d{1,3}[\.\)\-]\s+)/u', '', $l));
                        if ($l !== '') $linePool[] = $l;
                    }
                }
                $linePool = array_values(array_unique($linePool));
                if (!empty($linePool)) {
                    $take = min(5, max(3, count($linePool)));
                    $fallback = array_slice($linePool, 0, $take);
                    $bullets = array_map(fn($t) => ['text' => $t, 'chunk_id' => null, 'ord' => null, 'score' => 0.0], $fallback);
                }
            }

            // Refino opcional por LLM (linha a linha)
            if ($strictness < 3) {
                try {
                    $llm = new LlmService();
                    if ($llm->enabled()) {
                        foreach ($bullets as &$b) {
                            $txt = (string)($b['text'] ?? '');
                            $rv  = $llm->rewriteLine($txt, $format);
                            $b['text'] = is_string($rv) && strlen(trim($rv)) > 0 ? trim($rv) : $txt;
                        }
                        unset($b);
                        $llmUsed = true;
                    }
                } catch (\Throwable $e) {}
            }

            $final   = $this->renderBulletsSimple($bullets, $format);
if (trim($final) === '') {
    // Fallback extra: 1 bullet + parágrafo (>=120 chars)
    $plain = trim(preg_replace('/\s+/', ' ', $this->combineChunksForList($neighbors)));
    $para  = mb_substr($plain, 0, 500, 'UTF-8');
    if (mb_strlen($para, 'UTF-8') < 120) {
        $para = str_pad($para, 120, ' …');
    }
    $first = $para;
    $p = mb_strpos($para, '. ');
    if ($p !== false) $first = mb_substr($para, 0, $p+1, 'UTF-8');
    $final = "- " . trim($first) . "\n\n" . trim($para);
}

            $sources = $this->buildCitationsFromWindow($neighbors, $citationsCount);

            return response()->json([
                'ok' => true,
                'query' => $query,
                'top_k' => $k,
                'used_doc' => intval($docId),
                'used_chunks' => count($neighbors),
                'mode_used' => 'summary',
                'format' => $format,
                'answer' => $final,
                'sources' => $sources,
                'debug' => [
                    'mode' => $llmUsed ? 'llm_summary_bulleted_refine' : 'extractive_summary_bulleted',
                    'best_ord' => $bestOrd,
                    'llm_used' => $llmUsed
                ],
            ]);
        }

        // ===== DIRECT + LLM opcional =====
        if ($strictness < 3) {
            try {
                $llm = new LlmService();
                if ($llm->enabled()) {
                    $directive = $this->buildDirectRewriteDirective($strictness);
                    $rewrite   = $llm->answerFromContext($directive . ' ' . $query, $combined, $extractive);
                    if (is_string($rewrite) && strlen(trim($rewrite)) > 0) {
                        $final   = trim($rewrite);
                        $llmUsed = true;
                    }
                }
            } catch (\Throwable $e) {}
        }

        $final   = $this->formatAs($final, $format);
        $sources = $this->buildCitationsFromNeighbors($neighbors, $citationsCount);

        return response()->json([
            'ok' => true,
            'query' => $query,
            'top_k' => $k,
            'used_doc' => intval($docId),
            'used_chunks' => count($neighbors),
            'mode_used' => $modeUsed,
            'format' => $format,
            'answer' => $final,
            'sources' => $sources,
            'debug' => [
                'mode' => $llmUsed ? 'llm_summarize_from_context' : 'extractive_no_llm',
                'best_ord' => $bestOrd,
                'neighbors' => array_map(fn($n) => ['id' => $n->id, 'ord' => $n->ord], $neighbors),
                'llm_used' => $llmUsed,
                'llm_provider' => env('LLM_PROVIDER', 'none'),
            ],
        ]);
    }

    // ============================== Helpers ==============================

    private function isPgsql(): bool
    {
        try { return DB::connection()->getDriverName() === 'pgsql'; } catch (\Throwable $e) { return false; }
    }

    private function isMysql(): bool
    {
        try { return DB::connection()->getDriverName() === 'mysql'; } catch (\Throwable $e) { return false; }
    }

    private function pgFtsEnabled(): bool
    {
        return filter_var(env('RAG_ENABLE_PG_FTS', true), FILTER_VALIDATE_BOOLEAN);
    }

    private function tryPgFts(int $docId, int $k, array $tokensRaw): array
    {
        $ftsOr = implode(' | ', $tokensRaw);
        $ftsSql = "
            SELECT id, ord, content, document_id,
                   ts_rank_cd(to_tsvector('portuguese', content),
                              websearch_to_tsquery('portuguese', :q)) AS rank
            FROM chunks
            WHERE document_id = :doc
              AND to_tsvector('portuguese', content) @@ websearch_to_tsquery('portuguese', :q)
            ORDER BY rank DESC
            LIMIT $k
        ";
        try {
            return DB::select($ftsSql, ['q' => $ftsOr, 'doc' => $docId]);
        } catch (\Throwable $e) {
            return [];
        }
    }

    private function detectMode(string $param, string $q): string
    {
        $param = $param ?: 'auto';
        $param = in_array($param, ['auto','direct','list','summary','quote','table']) ? $param : 'auto';
        if ($param !== 'auto') return $param;

        $n = mb_strtolower($q, 'UTF-8');
        if ($this->hasListIntent($n))   return 'list';
        if ($this->hasSummaryIntent($n))return 'summary';
        if ($this->hasQuoteIntent($n))  return 'quote';
        if ($this->hasTableIntent($n))  return 'table';
        return 'direct';
    }

    private function normalizeLength(string $len): string
    {
        $map = ['auto','short','medium','long','xl'];
        return in_array($len, $map) ? $len : 'auto';
    }

    private function hasListIntent(string $q): bool
    {
        $n = mb_strtolower($q, 'UTF-8');
        $hints = ['lista','listar','list ','enumerar','enumera','enumere','numerando','uma a uma','um a um','todas','todos','sem resumir'];
        foreach ($hints as $h) if (mb_strpos($n, $h, 0, 'UTF-8') !== false) return true;
        if (preg_match('/\blist\b/i', $q)) return true;
        return false;
    }

    private function hasSummaryIntent(string $q): bool
    {
        $n = mb_strtolower($q, 'UTF-8');
        foreach (['resumo','resuma','resumir','sumário','executivo','em linhas','síntese','sintese'] as $h)
            if (mb_strpos($n, $h, 0, 'UTF-8') !== false) return true;
        return false;
    }

    private function hasQuoteIntent(string $q): bool
    {
        $n = mb_strtolower($q, 'UTF-8');
        foreach (['citação','cite a frase','frase exata','trecho exato','entre aspas','o que disse','o que afirma'] as $h)
            if (mb_strpos($n, $h, 0, 'UTF-8') !== false) return true;
        return false;
    }

    private function hasTableIntent(string $q): bool
    {
        $n = mb_strtolower($q, 'UTF-8');
        foreach (['tabela','tabelar','colunas','chave valor','key value','kv','preços','planos','especificações','especificacao'] as $h)
            if (mb_strpos($n, $h, 0, 'UTF-8') !== false) return true;
        return false;
    }

    private function loadOrdWindow(int $docId, int $startOrd, int $endOrd): array
    {
        $endOrd = max($endOrd, $startOrd);
        return DB::select("
            SELECT id, ord, content, document_id
            FROM chunks
            WHERE document_id = :doc
              AND ord BETWEEN :a AND :b
            ORDER BY ord ASC
        ", ['doc' => $docId, 'a' => $startOrd, 'b' => $endOrd]);
    }

    private function loadAllChunks(int $docId): array
    {
        return DB::select("
            SELECT id, ord, content, document_id
            FROM chunks
            WHERE document_id = :doc
            ORDER BY ord ASC
        ", ['doc' => $docId]);
    }

    private function combineChunks(array $rows): string
    {
        $combined = '';
        foreach ($rows as $n) $combined .= "\n" . $this->repairText((string) $n->content);
        return trim($combined);
    }

    private function combineChunksForList(array $rows): string
    {
        $out = [];
        foreach ($rows as $n) {
            $s = (string)$n->content;
            $s = preg_replace('/([A-Za-zÀ-ÿ])-\s*\n\s*([A-Za-zÀ-ÿ])/', '$1$2', $s);
            $s = preg_replace('/[ \t]+/u', ' ', $s);
            $s = trim($s);
            $out[] = $s;
        }
        return trim(implode("\n\n", $out));
    }

    private function tokensRaw(string $s): array
    {
        if (!preg_match_all('/\p{L}{3,}/u', $s, $m)) return [];
        return array_map(fn($x) => mb_strtolower($x, 'UTF-8'), $m[0]);
    }

    private function tokensNorm(string $s): array
    {
        $s = mb_strtolower($s, 'UTF-8');
        $t = @iconv('UTF-8', 'ASCII//TRANSLIT//IGNORE', $s);
        if ($t !== false) $s = $t;
        $s = preg_replace('/[^a-z0-9]+/i', ' ', $s);
        $s = trim(preg_replace('/\s+/', ' ', $s));
        if ($s === '') return [];
        $parts = preg_split('/\s+/', $s);
        return array_values(array_filter($parts, fn($w) => strlen($w) >= 3));
    }

    private function repairText(string $s): string
    {
        $s = preg_replace('/([A-Za-zÀ-ÿ])-\s*\n\s*([A-Za-zÀ-ÿ])/', '$1$2', $s);
        $s = preg_replace('/\s*\n\s*/', ' ', $s);
        $s = preg_replace('/\s+/', ' ', $s);
        return trim($s);
    }

    private function splitSentences(string $s): array
    {
        $parts = preg_split('/(?<=[\.\!\?\”\"])\s+/u', $s, -1, PREG_SPLIT_NO_EMPTY);
        return array_values(array_filter(array_map('trim', $parts)));
    }

    private function extractAnswer(string $context, string $question): ?string
    {
        $qtoks = $this->tokensNorm($question);
        $sentences = $this->splitSentences($context);
        if (!count($sentences)) return null;

        $bestScore = -1.0; $best = null;
        foreach ($sentences as $s) {
            $stoks = $this->tokensNorm($s);
            if (!count($stoks)) continue;

            $is = array_intersect($qtoks, $stoks);
            $uni = array_unique(array_merge($qtoks, $stoks));
            $jacc = (count($uni) ? count($is) / count($uni) : 0.0);

            $must = $this->contextMustKeywords($qtoks, $context);

            $hits = 0;
            foreach ($must as $m) {
                foreach ($stoks as $t) {
                    if (mb_strpos($t, $m, 0, 'UTF-8') !== false) { $hits++; break; }
                }
            }
            $score = $jacc + 0.02 * $hits;

            if ($score > $bestScore) { $bestScore = $score; $best = $s; }
        }

        if ($best !== null && $bestScore < 0.08) {
            $idx = array_search($best, $sentences, true);
            if ($idx !== false) {
                $out = $sentences[$idx];
                if ($idx + 1 < count($sentences)) $out .= ' ' . $sentences[$idx + 1];
                return trim($out);
            }
        }
        return $best;
    }

    private function contextMustKeywords(array $qtoks, string $context): array
    {
        $ctxTokens = $this->tokensNorm($context);
        $freq = array_count_values($ctxTokens);
        arsort($freq);

        $topCtx = array_slice(array_keys($freq), 0, 20);
        $topQ   = array_slice(array_values(array_unique($qtoks)), 0, 10);

        $must = array_values(array_unique(array_merge($topQ, $topCtx)));

        $must = array_values(array_filter($must, function($w){
            if (mb_strlen($w, 'UTF-8') < 3) return false;
            if (preg_match('/^\d+$/', $w)) return false;
            return true;
        }));

        return array_slice($must, 0, 16);
    }

    private function extractiveSummary(string $context, string $length): string
    {
        $sent = $this->splitSentences($context);
        if (empty($sent)) return 'Não há dados suficientes no documento para responder.';
        $n = count($sent);

        $take = 3;
        if ($length === 'short')  $take = 2;
        if ($length === 'medium') $take = min(5, $n);
        if ($length === 'long')   $take = min(10, $n);
        if ($length === 'xl')     $take = min(15, $n);

        $slice = array_slice($sent, 0, $take);
        return implode(' ', $slice);
    }

    private function extractNumberedItems(string $text): array
    {
        $items = [];
        $lines = preg_split('/\R/u', $text);
        foreach ($lines as $line) {
            $line = trim($line);
            if ($line === '') continue;
            if (preg_match('/^(\d{1,3})[\.\)\-]?\s+(.*)$/u', $line, $m)) {
                $num = intval($m[1]);
                $val = trim($m[2]);
                if ($val !== '') $items[$num] = $val;
            }
        }

        if (count($items) < 5) {
            if (preg_match_all('/(\b\d{1,3})[\.\)\-]?\s+([^\d][^\.]{2,}?)(?=(\b\d{1,3})[\.\)\-]?\s+|$)/su', $text, $mm, PREG_SET_ORDER)) {
                foreach ($mm as $m) {
                    $num = intval($m[1]);
                    $val = trim($m[2]);
                    if ($val !== '') $items[$num] = $val;
                }
            }
        }

        if (empty($items)) return [];
        ksort($items, SORT_NUMERIC);

        $clean = [];
        foreach ($items as $n => $val) {
            $val = preg_replace('/\s+/', ' ', $val);
            $val = trim($val, " \t\n\r\0\x0B-–—");
            if ($val !== '') $clean[$n] = $val;
        }
        return $clean;
    }

    private function extractKeyValuePairs(string $text): array
    {
        $pairs = [];
        $lines = preg_split('/\R/u', $text);
        foreach ($lines as $line) {
            $line = trim($line);
            if ($line === '' || mb_strlen($line, 'UTF-8') < 4) continue;
            if (preg_match('/^\s*([^\:\|]{2,50})\s*[:：]\s*(.+)$/u', $line, $m)) {
                $key = trim($m[1]);
                $val = trim($m[2]);
                if ($key !== '' && $val !== '') $pairs[$key] = $val;
            }
        }
        return $pairs;
    }

    private function extractQuote(string $text): ?string
    {
        if (preg_match('/[“"](.*?)[”"]/u', $text, $m) && isset($m[1])) {
            $q = trim($m[1]);
            if ($q !== '') return '“'.$q.'”';
        }
        return null;
    }

    private function buildQuoteFallback(string $combined, ?string $extractive): string
    {
        $q = $this->extractQuote($combined);
        if ($q) return $q;

        $sent = $this->splitSentences($combined);
        $txt  = trim((string)($sent[0] ?? $extractive ?? ''));
        if ($txt === '' && $combined !== '') {
            $txt = trim(mb_substr($combined, 0, 220, 'UTF-8'));
        }
        if ($txt === '') {
            $txt = 'Sem citação disponível no contexto.';
        }
        return '“'.$txt.'”';
    }

    private function formatNumberedList(array $items, string $format): string
    {
        $lines = [];
        $i = 1;
        foreach ($items as $val) {
            if ($format === 'markdown')      $lines[] = $i.'. '.$val;
            elseif ($format === 'html')      $lines[] = "<li>".e($val)."</li>";
            else                              $lines[] = $i.'. '.$val;
            $i++;
        }
        if ($format === 'html') return "<ol>\n".implode("\n", $lines)."\n</ol>";
        return implode("\n", $lines);
    }

    private function formatTable(array $pairs, string $format): string
    {
        if ($format === 'html') {
            $rows = [];
            foreach ($pairs as $k => $v) $rows[] = '<tr><th>'.e($k).'</th><td>'.e($v).'</td></tr>';
            return "<table>\n".implode("\n", $rows)."\n</table>";
        }
        if ($format === 'markdown') {
            $out = ["| Chave | Valor |","|---|---|"];
            foreach ($pairs as $k => $v) $out[] = "| ".str_replace('|','\|',$k)." | ".str_replace('|','\|',$v)." |";
            return implode("\n", $out);
        }
        $lines = [];
        foreach ($pairs as $k => $v) $lines[] = "$k: $v";
        return implode("\n", $lines);
    }

    private function formatAs(string $text, string $format): string
    {
        if ($format === 'html') {
            $parts = preg_split('/\R/u', trim($text));
            $parts = array_map(fn($t) => '<p>'.e($t).'</p>', array_filter($parts, fn($t) => $t !== ''));
            return implode("\n", $parts) ?: e($text);
        }
        return trim($text);
    }

    private function buildSummaryPrompt(string $length, int $strictness): string
    {
        $len = match ($length) {
            'short'  => 'Resumo curto (2-3 frases).',
            'medium' => 'Resumo objetivo (5-7 frases).',
            'long'   => 'Resumo detalhado (10-15 frases).',
            'xl'     => 'Resumo extenso, em parágrafos.',
            default  => 'Resumo objetivo.',
        };
        $guard = match ($strictness) {
            3 => 'Não use LLM. (fallback extrativo será aplicado)',
            2 => 'Reescreva apenas com base no contexto. NÃO adicione fatos.',
            1 => 'Reorganize de forma clara, sem adicionar informações externas.',
            default => 'Seja claro e natural, mas NÃO invente nada.',
        };
        return "{$len} {$guard}";
    }

    private function buildDirectRewriteDirective(int $strictness): string
    {
        return match ($strictness) {
            2 => 'Reescreva de forma clara e direta, SEM adicionar fatos fora do contexto.',
            1 => 'Reescreva de forma clara; pode reorganizar levemente, sem adicionar nada externo.',
            default => 'Responda de forma fluente e natural, SEM inventar nada e estritamente com base no contexto.',
        };
    }

    private function buildCitationsFromNeighbors(array $neighbors, int $n): array
    {
        if ($n <= 0) return [];
        $out = [];
        foreach ($neighbors as $row) {
            $out[] = ['document_id' => $row->document_id ?? null, 'ord' => $row->ord, 'id' => $row->id];
            if (count($out) >= $n) break;
        }
        return $out;
    }

    private function buildCitationsFromWindow(array $neighbors, int $n): array
    {
        if ($n <= 0) return [];
        $out = [];
        foreach ($neighbors as $row) {
            $out[] = ['document_id' => $row->document_id ?? null, 'ord' => $row->ord, 'id' => $row->id];
            if (count($out) >= $n) break;
        }
        return $out;
    }

    private function renderBulletsSimple(array $bullets, string $format): string
    {
        $lines = [];
        foreach ($bullets as $b) {
            $t = trim((string)($b['text'] ?? ''));
            if ($t === '') continue;
            if ($format === 'html') $lines[] = '<li>'.e($t).'</li>';
            else                    $lines[] = '- '.$t;
        }
        if ($format === 'html') return "<ul>\n".implode("\n", $lines)."\n</ul>";
        return implode("\n", $lines);
    }

    private function expandQueryTerms(array $terms, string $query, int $docId): array
    {
        $base = $terms;

        // bigrams da query
        $qraw = $this->tokensRaw($query);
        for ($i=0; $i < count($qraw)-1; $i++) {
            $base[] = $qraw[$i].' '.$qraw[$i+1];
        }

        // prefixos para match parcial
        foreach ($terms as $t) {
            if (mb_strlen($t, 'UTF-8') >= 6) {
                $base[] = mb_substr($t, 0, 5, 'UTF-8');
            }
        }

        // singular/plural simples
        foreach ($terms as $t) {
            if (preg_match('/s$/u', $t)) $base[] = preg_replace('/s$/u', '', $t);
            else $base[] = $t.'s';
        }

        // top tokens de amostra do documento
        $sample = DB::select("
            SELECT content FROM chunks
            WHERE document_id = :doc
            ORDER BY ord ASC
            LIMIT 5
        ", ['doc' => $docId]);
        $docTokens = [];
        foreach ($sample as $r) {
            $docTokens = array_merge($docTokens, $this->tokensNorm((string)$r->content));
        }
        $freq = array_count_values($docTokens);
        arsort($freq);
        $topDoc = array_slice(array_keys($freq), 0, 8);
        $base = array_merge($base, $topDoc);

        $base = array_values(array_unique(array_filter(array_map('trim', $base))));
        return $base;
    }

    // =================== NOVOS HELPERS (GENÉRICOS) ===================

    private function repairTextKeepBreaks(string $s): string
    {
        // remove hifenização de quebra de linha
        $s = preg_replace('/([A-Za-zÀ-ÿ])-\s*\n\s*([A-Za-zÀ-ÿ])/', '$1$2', $s);
        // normaliza espaços
        $s = preg_replace('/[ \t]+/u', ' ', $s);
        // preserva quebras (uma por linha)
        $s = preg_replace('/\s*\n\s*/u', "\n", $s);
        // comprime quebras múltiplas
        $s = preg_replace('/\n{2,}/u', "\n", $s);
        return trim($s);
    }

    private function splitSentencesLoose(string $s): array
    {
        // primeiro quebra por linha para capturar bullets/títulos sem pontuação
        $lines = preg_split('/\R+/u', (string)$s, -1, PREG_SPLIT_NO_EMPTY);
        $pieces = [];
        foreach ($lines as $line) {
            $line = trim($line);
            if ($line === '') continue;

            // remove marcador de bullet/numeração no início
            $line = preg_replace('/^\s*(?:[\-–—\*•]\s+|\d{1,3}[\.\)\-]\s+)/u', '', $line);

            // se houver pontuação de fim de frase, segmenta; senão considera a linha inteira
            $parts = preg_split('/(?<=[\.\!\?\”\"])\s+/u', $line, -1, PREG_SPLIT_NO_EMPTY);
            if (count($parts) > 1) {
                foreach ($parts as $p) { $p = trim($p); if ($p !== '') $pieces[] = $p; }
            } else {
                $pieces[] = $line;
            }
        }
        return $pieces;
    }


private function ensureDoubleQuoted(string $s): string
{
    $s = strip_tags($s ?? '');
    $s = preg_replace('/\s+/', ' ', trim($s));
    if ($s === '') {
        return '""';
    }
    $s = trim($s, " \t\n\r\0\x0B\"'");
    return '"' . $s . '"';
}


private function repairSummary(?string $summary, array $usedChunksTexts): string
{
    $s = trim((string) $summary);
    $lines = preg_split('/\r?\n/', $s);
    $bulletsExisting = array_values(array_filter($lines, fn($l) => preg_match('/^\s*[-*•]\s+/', $l)));
    if (count($bulletsExisting) >= 3 && count($bulletsExisting) <= 7) {
        return $s;
    }
    $uniq = [];
    foreach ($usedChunksTexts as $txt) {
        $txt = trim(preg_replace('/\s+/', ' ', (string) $txt));
        foreach (preg_split('/(?<=[\.\!\?])\s+/', $txt) as $sent) {
            $sent = trim($sent);
            $len  = mb_strlen($sent);
            if ($len >= 40 && $len <= 220) {
                $uniq[$sent] = true;
            }
        }
    }
    $sentences = array_keys($uniq);
    $picked    = array_slice($sentences, 0, 5);
    $bullets   = array_map(fn($t) => '- ' . rtrim($t, '. '), $picked);
    $paragraph = '';
    if (count($bullets) < 3) {
        $join = implode(' ', array_slice($sentences, 0, 6));
        $join = trim(preg_replace('/\s+/', ' ', $join));
        if (mb_strlen($join) < 120) {
            $join = str_pad($join, 120, ' …');
        }
        if (!empty($picked)) {
            $bullets = ['- ' . rtrim($picked[0], '. ')];
        } else {
            $bullets = ['- Resumo dos pontos-chave indisponível nos trechos analisados.'];
        }
        $paragraph = $join;
    }
    return implode("\n", $bullets) . ($paragraph ? "\n\n" . $paragraph : '');
}

}